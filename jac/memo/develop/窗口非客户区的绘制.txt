1.根据需要，要改变nc区的大小.
　响应WM_NCCALCSIZE可改变nc区的大小.关键在于lParam,msdn上说当wParam为True时，
　lParam为LPNCCALCSIZE_PARAMS的指定，当wParam为False时为LPRECT,做了些实验发现
　只有第一次时wParam为False，LPNCCALCSIZE_PARAMS的语义相当复杂，不过我们只用
　看第一个RECT就成.它表是窗口客户区的大小.当lParam为LPRECT时，也同样.只用改变
　客户区的大小，相应的就改变了非客户区的大小.


2.响应WM_NCPAINT绘制窗口的Title和Border


3.响应WM_NCHITTEST，在这里要做的是改变原来的HTMAXBUTTON,HTMINBUTTON,HTMINBUTTON　区域.


4.响应WM_NCACTIVATE,在这里不能调用默认的处理因为当窗口是非激活状态时会画出默认的Title


5.响应WM_ACTIVATEAPP,在这里先调用默认的处理.然后再自绘nc区.


6.响应       

        0x00AE://WM_NCUAHDRAWCAPTION
        0x00AF://WM_NCUAHDRAWFRAME
　这两条消息是在xp sp2后加的.xp在以前有个bug在某些时候Titlebar会画错.
　在这里不能调用默认处理，直接自绘nc区.


7.最后要响应WM_NCMOUSEMOVE,WM_NCLBUTTONDOWN,WM_NCLBUTTONUP,
　WM_NCMOUSELEAVE,来处理Titlebar上的鼠标动作.

另外最好调用SetWindowTheme(hWnd, L"", L""),和
DWORD dwAttr = 1;
DwmSetWindowAttribute(hWnd, 2, &dwAttr, 4));
以防止xp,和vista用主题绘制窗口nc区.
这两条函数分别是xp和vista特有的，所以只能动态加载相应的dll以调用之.  
在CDBFrame::OnCreate里面
ModifyStyle(WS_CAPTION, 0);	//没有这行，最大化的时候有窗口边缘8像素的被截掉了

HINSTANCE hInst = LoadLibrary(_T("UxTheme.dll"));
if (hInst)
{
typedef HRESULT (WINAPI *PFUN_SetWindowTheme)(HWND, LPCWSTR, LPCWSTR);

PFUN_SetWindowTheme pFun = (PFUN_SetWindowTheme)GetProcAddress(hInst, "SetWindowTheme");

if (pFun)
pFun(GetSafeHwnd(), L"", L"");	 //去掉xp主体

FreeLibrary(hInst);
}

hInst = LoadLibrary(_T("dwmapi.dll"));
if (hInst)
{
typedef HRESULT (WINAPI * TmpFun)(HWND,DWORD,LPCVOID,DWORD);
TmpFun DwmSetWindowAttributeEX = (TmpFun)::GetProcAddress(hInst, "DwmSetWindowAttribute");

if (DwmSetWindowAttributeEX)
{
DWORD dwAttr = 1;
DwmSetWindowAttributeEX(GetSafeHwnd(), 2, &dwAttr, 4);	//去掉vista特效
}

FreeLibrary(hInst);
}

BOOL CDBFrame::OnNcActivate( BOOL bActive )	 //避免每次激活时vista重画边框
{
return TRUE;
}

XP下一切正常的时候, 在WIN7下会出现厚边框.  经过常规非客户区的NC_XXX处理后, 当窗口失去焦点, 就会发现WIN7给绘了一个厚厚的边框.
――――――――――――――――――――――――-
网上找了一下, 发现统统抄录一个解法:
就是在OnNcActivate( BOOL bActive )的时候直接返回TRUE, 如下:
BOOL CFrameWnd::OnNcActivate( BOOL bActive )
{
return TRUE;
}
事实上这个方法确实看不见厚边框了, 但是这个方法是不对的, bActive需要判断, 否则windows可能不会响应你的弹出对话框, 因为直接返回TRUE, 表示消息中止, 后续的WM_ACTIVATE靠谁来接续呢?  所以这个直接返回是错误的.
下面进入正解:
――――――――――――――――――――――――-
先放代码:
BOOL CFrameWnd::OnNcActivate( BOOL bActive )
{
if(bActive)
{
OnNcPaint(0);
return TRUE;
}
else
{
LockWindowUpdate();
OnNcPaint(0);
return FALSE;
}
}
BOOL  CFrameWnd::OnActivate( UINT nState,HWND hwndPrevious, BOOL bMinimized )
{
if(WA_INACTIVE==nState)
{
LockWindowUpdate(0);
}
return FALSE;
};
简要说一下原理, OnNcActivate的时候先阻止窗口绘制, 接下来window会收到绘制消息, 这个时候就绘制不了, 再然后window会收到WM_ACTIVATE, 这个时候再解锁,  不然窗口界面会死锁在那里
总结:
一. 如何正确处理OnNcActivate,  必须按它的参数来处理不同类型, 不能直接返回TRUE, 以解决对话框问题
二. 如何正确处理LockWindowUpdate, 让它在合理的时候锁定, 合理的时候解锁.















// RYFrameWnd.cpp : implementation file
//

#include "stdafx.h"
#include "EEE.h"
#include "RYFrameWnd.h"


const CRect CRYFrameWnd::rcNcRect(5, 25, 5, 5);

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CRYFrameWnd

IMPLEMENT_DYNCREATE(CRYFrameWnd, CFrameWnd)

CRYFrameWnd::CRYFrameWnd()
{
}

CRYFrameWnd::~CRYFrameWnd()
{
}


BEGIN_MESSAGE_MAP(CRYFrameWnd, CFrameWnd)
//{{AFX_MSG_MAP(CRYFrameWnd)
ON_WM_NCCALCSIZE()
ON_WM_NCPAINT()
ON_WM_NCHITTEST()
ON_WM_NCLBUTTONDOWN()
ON_WM_SETCURSOR()
//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRYFrameWnd message handlers

void CRYFrameWnd::OnNcCalcSize( BOOL bCalcValidRects, NCCALCSIZE_PARAMS* lpncsp )
{
CRect rc = lpncsp->rgrc[0];
rc.DeflateRect(rcNcRect);
lpncsp->rgrc[0] = rc;
}

void CRYFrameWnd::OnNcPaint()
{
CWindowDC dc(this);

CRect rc;
GetWindowRect(rc);

CRect rcClip;
GetClientRect(rcClip);
ClientToScreen(rcClip);

rcClip.OffsetRect(-rc.left, -rc.top);
rc.OffsetRect(-rc.left, -rc.top);

dc.ExcludeClipRect(rcClip);

CRect rcOut = rcClip;
rcOut.InflateRect(rcNcRect);

CRect rcIn = rcClip;
rcIn.InflateRect(1, 1, 1, 1);

dc.FillSolidRect(rcOut, 0xFFDABE);
dc.Draw3dRect(rcOut, 0xA79A94, 0xA79A94);
dc.Draw3dRect(rcIn, 0xFFC599, 0xFFC599);
}

UINT CRYFrameWnd::OnNcHitTest( CPoint point )
{
CRect rcWnd;
GetWindowRect(rcWnd);

CRect rcCap = rcWnd;
rcCap.bottom = rcCap.top + rcNcRect.top;
rcCap.top += 5;
rcCap.DeflateRect(20, 0, 20, 0);

CRect rcLeft = rcWnd;
rcLeft.right = rcLeft.left + 5;
rcLeft.DeflateRect(0, 20, 0, 20);

CRect rcTop = rcWnd;
rcTop.bottom = rcTop.top + 5;
rcTop.DeflateRect(20, 0, 20, 0);

CRect rcRight = rcWnd;
rcRight.left = rcRight.right - 5;
rcRight.DeflateRect(0, 20, 0, 20);

CRect rcBottom = rcWnd;
rcBottom.top = rcBottom.bottom - 5;
rcBottom.DeflateRect(20, 0, 20, 0);

CRect rcLeftTop = rcWnd;
rcLeftTop.right = rcLeftTop.left + 20;
rcLeftTop.bottom = rcLeftTop.top + 20;

CRect rcRightTop = rcWnd;
rcRightTop.left = rcRightTop.right - 20;
rcRightTop.bottom = rcRightTop.top + 20;

CRect rcLeftBottom = rcWnd;
rcLeftBottom.right = rcLeftBottom.left + 20;
rcLeftBottom.top = rcLeftBottom.bottom - 20;

CRect rcRightBottom = rcWnd;
rcRightBottom.left = rcRightBottom.right - 20;
rcRightBottom.top = rcRightBottom.bottom - 20;

if (rcCap.PtInRect(point))
return HTCAPTION;
else if (rcLeft.PtInRect(point))
return HTLEFT;
else if (rcTop.PtInRect(point))
return HTTOP;
else if (rcRight.PtInRect(point))
return HTRIGHT;
else if (rcBottom.PtInRect(point))
return HTBOTTOM;
else if (rcLeftTop.PtInRect(point))
return HTTOPLEFT;
else if (rcRightTop.PtInRect(point))
return HTTOPRIGHT;
else if (rcLeftBottom.PtInRect(point))
return HTBOTTOMLEFT;
else if (rcRightBottom.PtInRect(point))
return HTBOTTOMRIGHT;
else
return CFrameWnd::OnNcHitTest(point);
}


BOOL CRYFrameWnd::PreCreateWindow(CREATESTRUCT& cs)  
{
// TODO: Add your specialized code here and/or call the base class
cs.style = WS_VISIBLE | WS_POPUP | WS_SYSMENU  
//	 | WS_MINIMIZEBOX | WS_MAXIMIZEBOX
| WS_THICKFRAME
//	 | WS_BORDER
;

cs.dwExStyle = WS_EX_WINDOWEDGE;

return CFrameWnd::PreCreateWindow(cs);
}

void CRYFrameWnd::OnNcLButtonDown(UINT nHitTest, CPoint point )
{
CFrameWnd::OnNcLButtonDown( nHitTest, point );
}

BOOL CRYFrameWnd::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message)  
{
// TODO: Add your message handler code here and/or call default

return CWnd::OnSetCursor(pWnd, nHitTest, message);
}